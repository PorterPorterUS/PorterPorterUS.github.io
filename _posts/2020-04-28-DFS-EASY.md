---
layout: post
author: Xusheng Ji
title: "dfs easy"
tags: algorithm leetcode
---

{% include lib/mathjax.html %}


<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: [
      "MathMenu.js",
      "MathZoom.js",
      "AssistiveMML.js",
      "a11y/accessibility-menu.js"
    ],
    jax: ["input/TeX", "output/CommonHTML"],
    TeX: {
      extensions: [
        "AMSmath.js",
        "AMSsymbols.js",
        "noErrors.js",
        "noUndefined.js",
      ]
    }
  });
</script>



DFS easy 

#### 938: 把二叉树中每个在 [low, high] 这个范围的的节点的value 加起来

设置一个公共的 sum, 然后循环遍历,每层都都把当前节点的值累加到公共的 sum 上.  

```c
class Solution {
    public int sum;
    public int rangeSumBST(TreeNode root, int low, int high) {
        if(root == null) return 0;
        if(root.val>=low && root.val<=high){
          sum+=root.val;
        }        
       if(root.left!=null)  rangeSumBST(root.left,low,high);
       if(root.right!=null) rangeSumBST(root.right,low,high); 
      return sum;
      }
}
```

#### 783 && 530 求二叉树中所有差值绝对值最小的值
```c
class Solution {
    private int res = Integer.MAX_VALUE;
    private Integer pre = null;
    public int minDiffInBST(TreeNode root) {
         if(root.left!=null) minDiffInBST(root.left);
         if(pre!=null) {res = Math.min(res,root.val - pre);}
          pre = root.val; 
         if(root.right!=null) minDiffInBST(root.right); 
        return res;
    }
}
```

#### 110 平衡二叉树(求最长路径可以直接一行代码解决，但是最短路径不行, 必须判断左右子树是否为空, 因为假如左子树为空，代入最后一行返回的是最左侧子树，但是在左子树为空的判断内返回的应该是右侧子树)
每一层满足的条件 = 当前层满足 + 下一层满足 
意思就是说每一个节点都需要满足同样的条件
```c
public boolean isBalanced(TreeNode root) {
        if(root == null) return true;
        int left = height(root.left);
        int right = height(root.right);
        if(Math.abs(left-right)<=1 && isBalanced(root.left) && isBalanced(root.right)){return true;}
        // if(root.left!=null) { left = height(root.left);}
        // if(root.right!=null) {right = height(root.right);}
        // if(Math.abs(left-right)<=1 && isBalanced(root.left) && isBalanced(root.right)){return true;}
        return false;
    }
```

计算整棵树的高度
```c private int height(TreeNode root){
      if(root == null) return 0;
      //if(root.left == null) return 1+height(root.right);
      //if(root.right == null) return 1+height(root.left);
      return Math.max(height(root.left),height(root.right))+1;
    }
```

#### 111 二叉树的最短深度

```c 
class Solution {
    public int minDepth(TreeNode root) {
      if(root == null) return 0;
      if(root.left == null) return 1+minDepth(root.right);
      if(root.right == null) return 1+minDepth(root.left);
      return Math.min(minDepth(root.left),minDepth(root.right))+1;
    }
}
```
#### 104 二叉树的最长深度
```c 
class Solution {
    public int maxDepth(TreeNode root) {
        if(root == null) return 0;
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }
}
```
#### 559 N叉树的最长深度
```c
class Solution {
    public int maxDepth(Node root) {
        if(root == null) return 0;
        int max = 0;
        for(Node n:root.children){
          max = Math.max(max,maxDepth(n));
        }
        return 1+max;
    }
}
```










