---
layout: post
author: Xusheng Ji
title: "dfs easy"
tags: algorithm leetcode
---

{% include lib/mathjax.html %}


<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: [
      "MathMenu.js",
      "MathZoom.js",
      "AssistiveMML.js",
      "a11y/accessibility-menu.js"
    ],
    jax: ["input/TeX", "output/CommonHTML"],
    TeX: {
      extensions: [
        "AMSmath.js",
        "AMSsymbols.js",
        "noErrors.js",
        "noUndefined.js",
      ]
    }
  });
</script>



DFS easy 

#### 938: sum all the nodes with values within low to high

设置一个公共的 sum, 然后循环遍历,每层都都把当前节点的值累加到公共的 sum 上.  

```c
class Solution {
    public int sum;
    public int rangeSumBST(TreeNode root, int low, int high) {
        if(root == null) return 0;
        if(root.val>=low && root.val<=high){
          sum+=root.val;
        }        
       if(root.left!=null)  rangeSumBST(root.left,low,high);
       if(root.right!=null) rangeSumBST(root.right,low,high); 
      return sum;
      }
}
```



However, in many cases there are replicates in array. 

#### First element

We abstract the array as 00000111111. To find the left edge, that is, the first 1, when we meet one 1, we cannot simply return the index. Rather, we need to shrink right boundary.

```c
// l < r
int binary_search(int *a, int n, int target) {
    int l = 0, r = n, mid; // set r as n, so the condition in while loop is l < r
    while (l < r) {
        mid = (l + r) / 2;
        if (a[mid] == 0) l = mid + 1;
        else r = mid;
    }
    return r
}

// l <= r
int binary_search(int *a, int n,, int target) {
    int l = 0, r = n-1, mid;
    while (l <= r) {
       	mid =  (l + r) / 2;
        if (a[mid] == 0) l = mid + 1;
        else r = mid - 1;
    }
    return r + 1;
}
```

 If all elements are 0, binary search will return `n` , which means there is no desirable value in array. 



