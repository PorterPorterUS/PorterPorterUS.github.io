---
layout: post
author: Xusheng Ji
title: "dfs graph search"
tags: algorithm leetcode
---

{% include lib/mathjax.html %}


<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: [
      "MathMenu.js",
      "MathZoom.js",
      "AssistiveMML.js",
      "a11y/accessibility-menu.js"
    ],
    jax: ["input/TeX", "output/CommonHTML"],
    TeX: {
      extensions: [
        "AMSmath.js",
        "AMSsymbols.js",
        "noErrors.js",
        "noUndefined.js",
      ]
    }
  });
</script>


DFS 图搜问题 

#### 785: 判断图是否是Bi-partile

思路: 对图中的每个节点进行check, 如果访问过了就跳过，没访问过就进行DFS涂色.


DFS内部逻辑:  先查看当前节点是否完成涂色, 如果已经涂色完成，那么检查节点的颜色和马上要染色的颜色是否相同。
如果没染色, 则对其染色，然后对所有邻居节点染相反的颜色，如果任意一个节点返回false，那么就返回false，不然全部通过的话，则返回true。

```c
class Solution {
    public boolean isBipartite(int[][] graph) {
        int[] visited = new int[graph.length];
        for(int i = 0 ;i < graph.length;i++){
          if(visited[i]==0){
            if(!dfs(i,graph,1,visited)) return false;
          }
        }
      return true;
    }
    private boolean dfs(int node,int[][] graph,int color,int[] visited){
      if(visited[node]!=0){
        return visited[node]==color;
      }
      visited[node]=color;
      for(int g:graph[node]){
        if(!dfs(g,graph,-color,visited)) return false;
      }
      return true;
      
    }
    
}


```







