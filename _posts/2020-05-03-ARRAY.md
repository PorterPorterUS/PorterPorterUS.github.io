---
layout: post
author: Xusheng Ji
title: "Array "
tags: algorithm leetcode
---

{% include lib/mathjax.html %}


<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: [
      "MathMenu.js",
      "MathZoom.js",
      "AssistiveMML.js",
      "a11y/accessibility-menu.js"
    ],
    jax: ["input/TeX", "output/CommonHTML"],
    TeX: {
      extensions: [
        "AMSmath.js",
        "AMSsymbols.js",
        "noErrors.js",
        "noUndefined.js",
      ]
    }
  });
</script>



Array

#### 870 重新洗牌

Given two arrays A and B of equal size, the advantage of A with respect to B is the number of indices i for which A[i] > B[i]. Return any permutation of A that maximizes its advantage with respect to B.



```java
class Solution {
    public int[] advantageCount(int[] A, int[] B) {
        Arrays.sort(A);
        int n=A.length;
        int[] res= new int[n];
        PriorityQueue<int[]> pq= new PriorityQueue<>((a,b)->b[0]-a[0]);
        for (int i=0; i<n; i++) pq.add(new int[]{B[i], i});
        int lo=0, hi=n-1;
        while(!pq.isEmpty()){
            int[] cur= pq.poll();
            int idx=cur[1], val=cur[0];
            if (A[hi]>val) res[idx]=A[hi--];
            else res[idx]=A[lo++];
        }
        return res;
    }  
}

```

思路： 


1.首先对A数组进行排序 


2.然后对B进行倒叙存储在PriorityQueue中


3.每次从PQ中pop出一个元素,(代表着第几大元素,比如说第一次pop出来的是最大的,第2次pop出来的是第二大的),和A中的目前最大元素做对比，
如果A中的元素更大,则最大位置存储A,否在从最小位置开始存储A





#### 915 把数组分区,分为两个子数组, 使得左侧子数组的最大值完全小于， 右侧子数组的最小值.


```c
class Solution {
    public int partitionDisjoint(int[] A) {
        int max = A[0];
        int prevMax = A[0];
        int res = 0;
        for(int i =0 ; i < A.length; i++){
           max = Math.max(max,A[i]);  
          if(A[i]<prevMax){
            res= i;
            prevMax = max;
          }
          
        }
        return res+1;
        
    }
}
```


思路:遍历整个数组,随时记录当前的最大值max, 以及本元素之前的最大值preMax,
如果当前的元素小于preMax,那么当前元素属于结果集合,更新res index,然后把preMax更新为max value.





#### 88 EASY 给定两个排序的整数数组nums1和nums2，将nums2合并为nums1作为一个排序的数组。 在nums1和nums2中初始化的元素数分别为m和n。 您可能会假设nums1的大小等于m + n，以使其具有足够的空间来容纳nums2中的其他元素。

```java

class Solution {
    public void merge(int A[], int m, int B[], int n) {
    int i=m-1, j=n-1, k=m+n-1;
    while (i>-1 && j>-1) A[k--]= (A[i]>B[j]) ? A[i--] : B[j--];
    while (j>-1)         A[k--]=B[j--];
    
    }
}

```


思路: 


1. 因为最后大小为m+n-1,那么从后往前的计算结果，最后一位是k=m+n-1,


2.A[k] = (A[i]>B[j]) ? A[i--] : B[j--];





#### 283 给定一个整数数组nums，将所有0移到其末尾，同时保持非零元素的相对顺序。


```java

class Solution {
    public void moveZeroes(int[] nums) {
        int index=0;
        for(int i=0;i<nums.length;i++){
            if(nums[i]!=0){
              nums[index]=nums[i];
              index++;}
        }
        
        for(int i=nums.length-1;i>=index;i--){
            nums[i]=0;
        }
        
    }
}

```









