---
layout: post
author: Xusheng Ji
title: "dfs Tree search"
tags: algorithm leetcode
---

{% include lib/mathjax.html %}


<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: [
      "MathMenu.js",
      "MathZoom.js",
      "AssistiveMML.js",
      "a11y/accessibility-menu.js"
    ],
    jax: ["input/TeX", "output/CommonHTML"],
    TeX: {
      extensions: [
        "AMSmath.js",
        "AMSsymbols.js",
        "noErrors.js",
        "noUndefined.js",
      ]
    }
  });
</script>



DFS TREE 问题

### 98: 判断一个TREE是否是合法的BST

一个树如果当前节点的value 大于左侧子树的所有节点, 并且当前节点的VALUE小于右侧子树的所有节点, 并且左右子树都是valid BST
那么整棵树也是valid BST.

#### 思路： 中序遍历时，判断当前节点是否大于中序遍历的前一个节点，如果大于，说明满足 BST，继续遍历；否则直接返回 false。


#### 在TREE的遍历当中, 如果需要往下一步走的话，前一步要返回false, 也就是说只有左侧子树或者右侧子树返回true的时候，才能进行下一步

```java
class Solution {
    private long pre = Long.MIN_VALUE;
    public boolean isValidBST(TreeNode root) {
        if(root == null) return true;
        if(!isValidBST(root.left)) return false;
        if(root.val<=pre) return false;
        pre = root.val;
        return isValidBST(root.right);
    }
}

```



### 1448: 有多少个good node?

如果对于一个节点, 从root到本身节点的路径上,它比这条路径上的所有节点都大, 那么它就是一个good node.

#### 思路： 前序遍历, 先检查当前节点是否是比max value大，如果是res++,然后尝试left node, 然后right node..


```java
class Solution {
    public int res = 0;
    public int goodNodes(TreeNode root) {
        helper(root,Integer.MIN_VALUE);
        return res;
    }
    private void helper(TreeNode root, int max){
        if(root == null) return;
        if(root.val>=max) res++;
        max = Math.max(max,root.val);
        //re
        helper(root.left,max);
        helper(root.right,max);
    }
}

```












