---
layout: post
author: Xusheng Ji
title: "TOOLS"
tags: algorithm leetcode
categories: TOOLS
---

{% include lib/mathjax.html %}


<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: [
      "MathMenu.js",
      "MathZoom.js",
      "AssistiveMML.js",
      "a11y/accessibility-menu.js"
    ],
    jax: ["input/TeX", "output/CommonHTML"],
    TeX: {
      extensions: [
        "AMSmath.js",
        "AMSsymbols.js",
        "noErrors.js",
        "noUndefined.js",
      ]
    }
  });
</script>



工具转换类 

========================backTracking的模版===============================


========================图搜BFS的模版===============================


========================图搜DFS的模版===============================


========================岛屿DFS的模版===============================




========================树的DFS遍历(前序,中序,后序)模版===============================
### 对于树的DFS，通常需要考虑两个问题，
### 1.树遍历的顺序，也就是inorder 或者 preOrder 或者 postOrder.
### 2.树遍历的写法, 也就是 从上而下(遍历完毕即可)？还是 从下而上(需要底层返回到本层，然后向上层返回)

### 一般来说, Tree的DFS有两种写法, 
### 第一种：从下而上, 在遍历左右子树的时候,接收返回值，并且将两个树的返回值操作处理，在本层返回. 
```java
 public int rangeSumBST(TreeNode root, int low, int high) {
        if(root == null) return 0;
        int sum3 = 0;
        if(root.val>=low && root.val<=high){
          sum3 = root.val;
        }
        int sum1 = rangeSumBST(root.left,low,high);
        int sum2 = rangeSumBST(root.right,low,high);
        return sum1+sum2+sum3;
    }
```
### 从下而上的时候, 也可以在遍历左右子树的时候直接return, 不需要在本层处理并且返回，也就是说左子树不需要和右子树沟通和互相处理，直接返回自个儿就行
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        if(root==null) {return null;}
        if(val<root.val){
            return searchBST(root.left,val);
        }else if(val>root.val){
            return searchBST(root.right,val);
        }
        return root;
    }
}


```

### 第二种: 从上而下, 遍历左右子树的时候, 不接收返回值，直接去遍历整棵树木, 完成遍历之后就会得到结果,不用在本层返回
```java
 public int sum = 0;
    public int rangeSumBST(TreeNode root, int low, int high) {
        if(root == null) return 0;
        if(root.val>=low && root.val<=high){
          sum+=root.val;
        }
        rangeSumBST(root.left,low,high);
        rangeSumBST(root.right,low,high);
        return sum;
    }

```



=========================常见题型和常用数据结构===================

### 总结题型：
### 1. 图的DFS/BFS, 树的DFS/BFS(树的DFS包括inorder,preorder,postorder)
### 1. 字典树
### 1. BackTracking
### 1. Stack
### 1. Array
### 1. Sliding Window


### 常用数据结构：
### 1. ArrayList+LinkedList
### 1. HashMap, TreeMap,LinkedHashMap
### 1. PriorityQueue
### 1. Queue
### 1. Stack
### 1. Deque





========================Collections中各种数据结构的时间复杂度==========================
### 3.List的时间复杂度
### 3.1 ArrayList, get by index的时间复杂度为O(1), remove/add/getByValue 的时间复杂度为o(n).
### 3.2 LinkedList or Double LinkedList,  remove/add 的时间复杂度为O(1), get的时间复杂度为o(n).
`end`
`end`

### 4.Map or Set时间复杂度
### 4.1 HashMap, 无论是get or put, 都是AVG为O(1), Worst为O(n)
```
put操作的流程：

第一步：key.hashcode()，时间复杂度O(1)。

第二步：找到桶以后，判断桶里是否有元素，如果没有，直接new一个entey节点插入到数组中。时间复杂度O(1)。

第三步：如果桶里有元素，并且元素个数小于6，则调用equals方法，比较是否存在相同名字的key，不存在则new一个entry插入都链表尾部。时间复杂度O(1)+O(n)=O(n)。

第四步：如果桶里有元素，并且元素个数大于6，则调用equals方法，比较是否存在相同名字的key，不存在则new一个entry插入都链表尾部。时间复杂度O(1)+O(logn)=O(logn)。红黑树查询的时间复杂度是logn。

通过上面的分析，我们可以得出结论，HashMap新增元素的时间复杂度是不固定的，可能的值有O(1)、O(logn)、O(n)。
```
### 4.2 TreeMap, 无论是get or put, 都是都是O(LogN)
### 4.3 LinkedHashMap,也就是一个桶内的元素是可以排序的,无论是get or put, 都是AVG为O(1), Worst为O(n)
`end`
`end`

### 5.Queue的时间复杂度
### 5.1 PriorityQueue, poll/add/offer为O(logN),而Peek为O(1), removes/contains为O(N).
### 5.2 Queue, insert/remove/size 都是O(1).
`end`
`end`

### 6.Stack的时间复杂度，push/pop/top都是O(1).
`end`
`end`

### 7.平衡二叉树的时间复杂度, 如果是遍历的话(BFS/DFS)应该是O(N), 如果是searching/insert/delete的话avg case应该是O(logN)，worse case应该是O(N)。
`end`
`end`

### 8.排序时间复杂度为,快速排序(平均为NlogN, 最坏n^2, 最好NlogN, 空间为NlogN), 
### 堆排序(平均为NlogN, 最坏NlogN,, 最好NlogN, 空间为1), 
### 归并排序(平均为NlogN, 最坏NlogN,, 最好NlogN, 空间为N), 
`end`
`end`


### 9.BFS or DFS时间复杂度 
### 9.1 BFS的时间复杂度,如果使用邻接表存储,则时间复杂度为O(V+E),如果使用邻接矩阵存储,则时间复杂度为O(V^2),
### 9.2 DFS的时间复杂度,如果使用邻接表存储,则时间复杂度为O(V+E),如果使用邻接矩阵存储,则时间复杂度为O(V^2),
`end`
`end`


================================类型转换以及各种数据结构的用法==================================



### 1. 对于index和result的初始化问题
```java
index = -1;
result = Integer.MAX_VALUE; //如果要求的是最小值 
result = Integer.MIN_VALUE; //如果要求的是最大值 
```

### 2. 对HashMap的Key进行排序 ----> TreeMap 
```java
//升序
TreeMap<Integer,String> map = new TreeMap<>(new Comparator<Integer>(){
@Override
public int compare(Integer ob1, Integer ob2){
 return ob1.compareTo(ob2);
}
});
```

### 2. 对HashMap的Values进行排序 ----> TreeMap 
```java
TreeMap<String,String> map1 = new TreeMap<String,String>();
List<Map.Entry<String, String>> list = new ArrayList<Map.Entry<String, String>>(map1.entrySet());

Collections.sort(list,new Comparator<Map.Entry<String,String>>() {
       //升序排序
public int compare(Map.Entry<String, String> o1, Map.Entry<String, String> o2) {
                return o1.getValue().compareTo(o2.getValue());
}});
```


### 3. ArrayList 转换为 int array

```java
int[] array = res.stream().mapToInt(Integer::valueOf).toArray();
```

### 3. ArrayList 转换为 int array

```java
ArrayList<Integer> list = IntStream.of(res)
                                   .boxed()
                                   .collect(Collectors.toCollection(ArrayList::new));
```


### 4. 建立一个数组, 数组中的每个元素都是一个ArrayList<>();
```java
List<Integer>[] list=new List[nums.length+1];
```

### 5. 对一个HashMap<Integer,Integer> map 进行遍历的两种办法

```java
 for(Map.Entry<String, Integer> entry: map.entrySet()){
      int key = entry.getKey();
      int value = entry.getValue();
 }
```

```java
 for(int key: map.keySet()){
      int value = map.get(key);
 }
```

### 6. 向空的hashmap中存放元素的两种方式
### 6.1  Hashmap的格式  HashMap<Integer,Integer>
```java
map.put(nums[i],map.getOrDefault(nums[i],0)+1);
```
### 6.2  Hashmap的格式为 HashMap<Integer,HashMap<Integer,Integer>> 
```java
 if(map.containsKey(i)){
     map.put(i,new ArrayList<>());
}
   map.get(i).add(j);
```

### 7.Integer to String 
### 想转换成什么,就用什么包
```java
int i=10;  
String s=String.valueOf(i);//Now it will return "10" 

```
### 8.String to Integer 
### 想转换成什么,就用什么包
```java
String s="200";  
int i=Integer.parseInt(s);  
```

### 9.String to char Array
```java
char[] arr = String.toCharArray();
```

### 10.char Array to String
```java
String string = new String(arr);
```

### 11.需要helper函数的情形
```java
1.参数个数与原函数不同
2.函数的返回值和原函数不同
```

### 12.把以逗号分隔的字符串，转换为ArrayList<>();
```java
new ArrayList<>(Arrays.asList(data.split(",")));
```

