---
layout: post
author: Xusheng Ji
title: "TOOLS"
tags: algorithm leetcode
categories: TOOLS
---

{% include lib/mathjax.html %}


<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: [
      "MathMenu.js",
      "MathZoom.js",
      "AssistiveMML.js",
      "a11y/accessibility-menu.js"
    ],
    jax: ["input/TeX", "output/CommonHTML"],
    TeX: {
      extensions: [
        "AMSmath.js",
        "AMSsymbols.js",
        "noErrors.js",
        "noUndefined.js",
      ]
    }
  });
</script>



工具转换类 
### 1.时间复杂度----->>> DFS and BFS
### 1.1 BFS的时间复杂度,如果使用邻接表存储,则时间复杂度为O(V+E),如果使用邻接矩阵存储,则时间复杂度为O(V^2),
### 1.2 DFS的时间复杂度,如果使用邻接表存储,则时间复杂度为O(V+E),如果使用邻接矩阵存储,则时间复杂度为O(V^2),





### 1.时间复杂度----->>> HashMap
### 1. 无论是get or put, 都是AVG为O(1), Worst为O(n)
```
put操作的流程：

第一步：key.hashcode()，时间复杂度O(1)。

第二步：找到桶以后，判断桶里是否有元素，如果没有，直接new一个entey节点插入到数组中。时间复杂度O(1)。

第三步：如果桶里有元素，并且元素个数小于6，则调用equals方法，比较是否存在相同名字的key，不存在则new一个entry插入都链表尾部。时间复杂度O(1)+O(n)=O(n)。

第四步：如果桶里有元素，并且元素个数大于6，则调用equals方法，比较是否存在相同名字的key，不存在则new一个entry插入都链表尾部。时间复杂度O(1)+O(logn)=O(logn)。红黑树查询的时间复杂度是logn。



通过上面的分析，我们可以得出结论，HashMap新增元素的时间复杂度是不固定的，可能的值有O(1)、O(logn)、O(n)。

```



### 1. 对于index和result的初始化问题
```java
index = -1;
result = Integer.MAX_VALUE; //如果要求的是最小值 
result = Integer.MIN_VALUE; //如果要求的是最大值 
```

### 2. 对HashMap的Key进行排序 ----> TreeMap 
```java
//升序
TreeMap<Integer,String> map = new TreeMap<>(new Comparator<Integer>(){
@Override
public int compare(Integer ob1, Integer ob2){
 return ob1.compareTo(ob2);
}
});
```

### 2. 对HashMap的Values进行排序 ----> TreeMap 
```java
TreeMap<String,String> map1 = new TreeMap<String,String>();
List<Map.Entry<String, String>> list = new ArrayList<Map.Entry<String, String>>(map1.entrySet());

Collections.sort(list,new Comparator<Map.Entry<String,String>>() {
       //升序排序
public int compare(Map.Entry<String, String> o1, Map.Entry<String, String> o2) {
                return o1.getValue().compareTo(o2.getValue());
}});
```


### 3. ArrayList 转换为 int array

```java
res.stream().mapToInt(Integer::valueOf).toArray();
```

### 4. 建立一个数组, 数组中的每个元素都是一个ArrayList<>();
```java
List<Integer>[] list=new List[nums.length+1];
```

### 5. 对一个HashMap<Integer,Integer> map 进行遍历的两种办法

```java
 for(Map.Entry<String, Integer> entry: map.entrySet()){
      int key = entry.getKey();
      int value = entry.getValue();
 }
```

```java
 for(int key: map.keySet()){
      int value = map.get(key);
 }
```

### 6. 向空的hashmap中存放元素的两种方式
### 6.1  Hashmap的格式  HashMap<Integer,Integer>
```java
map.put(nums[i],map.getOrDefault(nums[i],0)+1);
```
### 6.2  Hashmap的格式为 HashMap<Integer,HashMap<Integer,Integer>> 
```java
 if(map.containsKey(i)){
     map.put(i,new ArrayList<>());
}
   map.get(i).add(j);
```

### 7.Integer to String 
### 想转换为什么,就用什么包
```java
int i=10;  
String s=String.valueOf(i);//Now it will return "10" 

```
### 8.String to Integer 
### 想转换为什么,就用什么包
```java
String s="200";  
int i=Integer.parseInt(s);  
```



