---
layout: post
author: Xusheng Ji
title: "DFS Tree search"
tags: algorithm leetcode
categories: DFS
---

{% include lib/mathjax.html %}


<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: [
      "MathMenu.js",
      "MathZoom.js",
      "AssistiveMML.js",
      "a11y/accessibility-menu.js"
    ],
    jax: ["input/TeX", "output/CommonHTML"],
    TeX: {
      extensions: [
        "AMSmath.js",
        "AMSsymbols.js",
        "noErrors.js",
        "noUndefined.js",
      ]
    }
  });
</script>



DFS TREE 问题
### 1. 需要考虑 preOrder/inOrder/postOrder???
### 2. 需要考虑 从上而下(遍历完毕即得到答案,不需要在本层返回) 或者 从下而上A(接受左右子树的返回，并且处理他们，在本层返回结果) 或者 从下而上B(遍历左右子树的时候直接返回，不需要在本层处理另外一颗子树)
### 3. 从下而上B通常用于不同的树木的形状会产生不同的结果的 situation.
`end` `end` `end`
### 938.把二叉树中每个在 [low, high] 这个范围的的节点的value 加起来
### 时间复杂度：N是节点个数,因为是遍历操作, 所以时间复杂度为O(N).
### 空间复杂度: 取决于树木的高度, 最好的情况下树是平衡的，所以树的高度为logN,则空间复杂度为O(logN), 最坏的情况，树是chain shape的，高度为N,则空间复杂度为O(N).

### 前序遍历+从上而下
```java
class Solution {
  //前序遍历+从上而下
  int sum = 0;
    public int rangeSumBST(TreeNode root, int low, int high) {
        if(root == null) return 0;
        if(root.val <= high && root.val>=low){
          sum+= root.val;
        }
        rangeSumBST(root.left,low,high);
        rangeSumBST(root.right,low,high);
        return sum;
    }
}
```

### 前序遍历+从上而下A
```java
class Solution {
  //前序遍历+自下而上
    public int rangeSumBST(TreeNode root, int low, int high) {
        if(root == null){
          return 0;
        }
        int sum1 = 0;
        if(root.val>=low && root.val<=high){
           sum1 = root.val;
        }
        int sum2 = rangeSumBST(root.left,low,high);
        int sum3 = rangeSumBST(root.right,low,high);
        return sum1+sum2+sum3;
    }
}
```

### 104.二叉树的最大深度

### 时间复杂度：N是节点个数,因为是遍历操作, 所以时间复杂度为O(N).
### 空间复杂度: 取决于树木的高度, 最好的情况下树是平衡的，所以树的高度为logN,则空间复杂度为O(logN), 最坏的情况，树是chain shape的，高度为N,则空间复杂度为O(N).
### 前序遍历+从下而上A
```java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root == null) return 0;
        int left = 1+maxDepth(root.left);
        int right = 1+maxDepth(root.right);
        return Math.max(left,right);
    }
}
```
### 不能从上而下
``end`` ``end`` ``end``

### 559.N 叉树的最大深度
### 时间复杂度：N是节点个数,因为是遍历操作, 所以时间复杂度为O(N).
### 空间复杂度: 取决于树木的高度, 最好的情况下树是平衡的，所以树的高度为logN,则空间复杂度为O(logN), 最坏的情况，树是chain shape的，高度为N,则空间复杂度为O(N).
### 前序遍历+从下而上A
```java
class Solution {
    public int maxDepth(Node root) {
      if(root == null) return 0;  
      int max = 0;
      for(Node c: root.children){
          max = Math.max(max,maxDepth(c));
        }
      return 1+ max;
    }
}

```
### 111.二叉树的最小深度
### 时间复杂度：N是节点个数,因为是遍历操作, 所以时间复杂度为O(N).
### 空间复杂度: 取决于树木的高度, 最好的情况下树是平衡的，所以树的高度为logN,则空间复杂度为O(logN), 最坏的情况，树是chain shape的，高度为N,则空间复杂度为O(N).
### 前序遍历+从下而上B (遍历左右子树直接返回)
```java
class Solution {
    public int minDepth(TreeNode root) {
        if(root == null) return 0;
        if(root.left==null) return 1+minDepth(root.right);
        if(root.right==null) return 1+minDepth(root.left);
        return 1+Math.min(minDepth(root.left),minDepth(root.right));
    }
}
```

### 112. Path Sum
### 前序遍历+从下而上A(接收左右子树的返回，并且在本层返回他们的处理结果)
### 时间复杂度：O(m),m是二叉树中节点的个数
### 空间复杂度: 取决于树木的高度,最坏情况下是chain shape tree,则复杂度为O(M), 平均情况下为O(LogM).

```java
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if(root == null) return false;
        if(root.left==null && root.right == null){return targetSum == root.val;}
        boolean b1 = hasPathSum(root.left,targetSum-root.val);
        boolean b2 = hasPathSum(root.right,targetSum-root.val);
        return b1 || b2;
    }
}
```

### 101.镜像树
### 前序遍历+从下而上B (遍历左右子树直接返回)
### 时间复杂度：O(m),m是二叉树中节点的个数
### 空间复杂度: 取决于树木的高度,最坏情况下是chain shape tree,则复杂度为O(M), 平均情况下为O(LogM).

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if(root == null) return true;
        return dfs(root.left,root.right);
    }
    private boolean dfs(TreeNode left, TreeNode right){
      if(left == null && right == null) return true;
      if(left == null || right == null) return false;
      if(left!=null && right!=null&&left.val == right.val){
        return dfs(left.left,right.right)&&dfs(left.right,right.left);
      }
      return false;
    }
}

```
### 100.Same Tree
### 前序遍历+从下而上B (遍历左右子树直接返回)
### 时间复杂度：O(m),m是二叉树中节点的个数
### 空间复杂度: 取决于树木的高度,最坏情况下是chain shape tree,则复杂度为O(M), 平均情况下为O(LogM).

```java
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
      //要先写&&再写||
      //先判断是否两个都是空，再判断其中一个是空
        if(p==null && q==null) return true;
        if(p==null || q==null) return false;
        if(p!=null&&q!=null&&p.val==q.val){
          return isSameTree(p.left,q.left)&&isSameTree(p.right,q.right);
        }
        
        return false;
    }
}

```

### 783.Minimum Distance Between BST Nodes(返回二叉树中差值最小的值)
### 中序遍历 ++ 自上而下
### 通常情况下自下而上 都伴随着使用public变量 也伴随着使用void返回值的DFS函数
### 时间复杂度：O(m),m是二叉树中节点的个数
### 空间复杂度: 取决于树木的高度,最坏情况下是chain shape tree,则复杂度为O(M), 平均情况下为O(LogM).


```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
      //记录前后两个节点差值的最小值
    int min = Integer.MAX_VALUE;
    //记录前一个节点
    TreeNode prev;

    public int minDiffInBST(TreeNode root) {
        inorder(root);
        return min;
    }

    public void inorder(TreeNode root) {
        //边界条件判断
        if (root == null)
            return;
        //递归遍历左子树
        inorder(root.left);

        //记录当前节点和前一个节点的差值
        if (prev != null)
            min = Math.min(min, root.val - prev.val);
        //当前节点遍历之后就变成了前一个节点
        prev = root;

        //递归遍历右子树
        inorder(root.right);
    }
}
```

### 110.检查一棵树是不是Balanced Binary Tree
### 如果一棵树是平衡二叉树，那么可以很好的确定他的空间复杂度一定是O(LogN),不会是O(N),因为不会出现chain shape.
```java

```


### 700. Search in a Binary Search Tree
### 因为这是一道搜索问题, 所以不需要遍历整棵树，所以需要按照不同的情况遍历不同的左右子树, 所以需要使用自下而上B(遍历左右子树直接返回).
#### 如果根节点为空 root == null 或者根节点的值等于搜索值 val == root.val，返回根节点。
#### 如果 val < root.val，进入根节点的左子树查找 searchBST(root.left, val)。
#### 如果 val > root.val，进入根节点的右子树查找 searchBST(root.right, val)。
#### 返回根节点

### 时间复杂度: 因为是搜索操作而不是遍历操作, 时间复杂度：O(H)，其中 H 是树高。平均时间复杂度为 O(H)，最坏时间复杂度为 O(N)。
### 空间复杂度: 取决于树木的高度,最坏情况下是chain shape tree,则复杂度为O(M), 平均情况下为O(LogM).

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        if(root==null) {return null;}
        if(val<root.val){
            return searchBST(root.left,val);
        }else if(val>root.val){
            return searchBST(root.right,val);
        }
        return root;
    }
}

```

### 617. Merge Two Binary Trees
### 前序遍历+自下而上A
### 时间复杂度：O(m),m是二叉树中节点的个数
### 空间复杂度: 取决于树木的高度,最坏情况下是chain shape tree,则复杂度为O(M), 平均情况下为O(LogM).

```java
class Solution {
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if(root1==null) return root2;
        if(root2==null) return root1;
        root1.val+=root2.val;
        root1.left=mergeTrees(root1.left,root2.left);
        root1.right=mergeTrees(root1.right,root2.right);
        return root1;
    }
    
}
```

### 226. Invert Binary Tree
### 前序遍历+自上而下
### 时间复杂度：O(m),m是二叉树中节点的个数
### 空间复杂度: 取决于树木的高度,最坏情况下是chain shape tree,则复杂度为O(M), 平均情况下为O(LogM).
```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
      //递归的推出条件  
      if(root==null){
          return null;
        }
      //前序遍历
      TreeNode tmp = root.right;
      root.right = root.left;
      root.left = tmp;
      //把同样的逻辑推理到左节点和右节点
      invertTree(root.left);
      invertTree(root.right);
      return root;
    }
}

```

### 257. Binary Tree Paths(返回二叉树的所有路径)
### 前序遍历++从上而下
### 时间复杂度：O(m),m是二叉树中节点的个数
### 空间复杂度: 取决于树木的高度,最坏情况下是chain shape tree,则复杂度为O(M), 平均情况下为O(LogM).
```java
class Solution {
    public List<String> binaryTreePaths(TreeNode root) {
         List<String> res = new ArrayList<>();
         dfs(root,"",res);
        return res;
    }
    private void dfs(TreeNode root,String tmp,List<String> res){
      //退出条件
      if(root.left == null && root.right==null){
        tmp+=root.val;
        res.add(tmp);
      }
      //preOrder
      //首先处理本层
      tmp+=root.val+"->";
      //处理左侧子树
      if(root.left!=null) dfs(root.left,tmp,res); 
      //处理右侧子树
      if(root.right!=null) dfs(root.right,tmp,res); 
    }
}

```


### 98: 判断一个TREE是否是合法的BST

一个树如果当前节点的value 大于左侧子树的所有节点, 并且当前节点的VALUE小于右侧子树的所有节点, 并且左右子树都是valid BST
那么整棵树也是valid BST.

#### 思路： 中序遍历时，判断当前节点是否大于中序遍历的前一个节点，如果大于，说明满足 BST，继续遍历；否则直接返回 false。


#### 在TREE的遍历当中, 如果需要往下一步走的话，前一步要返回false, 也就是说只有左侧子树或者右侧子树返回true的时候，才能进行下一步

```java
class Solution {
    private long pre = Long.MIN_VALUE;
    public boolean isValidBST(TreeNode root) {
        if(root == null) return true;
        if(!isValidBST(root.left)) return false;
        if(root.val<=pre) return false;
        pre = root.val;
        return isValidBST(root.right);
    }
}

```



### 1448: 有多少个good node?

如果对于一个节点, 从root到本身节点的路径上,它比这条路径上的所有节点都大, 那么它就是一个good node.

#### 思路： 前序遍历, 先检查当前节点是否是比max value大，如果是res++,然后尝试left node, 然后right node..


```java
class Solution {
    public int res = 0;
    public int goodNodes(TreeNode root) {
        helper(root,Integer.MIN_VALUE);
        return res;
    }
    private void helper(TreeNode root, int max){
        if(root == null) return;
        if(root.val>=max) res++;
        max = Math.max(max,root.val);
        //re
        helper(root.left,max);
        helper(root.right,max);
    }
}

```




### 863: All Nodes Distance K in Binary Tree

我们给了一个二叉树（具有根节点root），一个目标节点和一个整数值K.返回一个距离目标节点距离为K的所有节点的值的列表。 答案可以以任何顺序返回。

#### 1.首先建立图, 因为对于TREE来说, 一个节点只能访问自己的左右子树, 并不能访问其父亲节点, 为了让树中的每个节点都能访问所有邻居，所以需要建图


#### 2.进行BFS, 首先建立Queue和HashSet, BFS内部首先获得当前queue.size(), 然后遍历size次, 每次poll出一个元素,对这个元素的所有邻居进行check,如果这个邻居不在HashSet中，则可以加入到下轮BFS中。


#### 3.每次进行once BFS, we need to K--;
 


```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<Integer> distanceK(TreeNode root, TreeNode target, int K) {
      List<Integer> res = new ArrayList<>();
      Queue<TreeNode> q = new LinkedList<>();
      HashSet<TreeNode> set =new HashSet<>();
      HashMap<TreeNode,List<TreeNode>> map = new HashMap<>();
      buildMap(root,null,map);
      
      if(!map.containsKey(target)) return res;
      q.offer(target);
      set.add(target);
      while(!q.isEmpty()){
        int size = q.size();
        if(K==0){
          for(int i = 0; i < size; i++){
            res.add(q.poll().val);
          }
          return res;
        }
        for(int i = 0; i < size ; i++){
          TreeNode c = q.poll();
          List<TreeNode> nei = map.get(c);
          for(TreeNode n : nei){
            if(set.contains(n))  continue;
            q.offer(n);
            set.add(n);
          }
        }
        K--;
        
      }
      return res;
        
    }
  
    private void buildMap(TreeNode root,TreeNode parent,HashMap<TreeNode,List<TreeNode>> map){
      if(root == null) return ;
      if(!map.containsKey(root)){
        map.put(root,new ArrayList<>());
      }
      if(parent!=null){
        map.get(root).add(parent);
        map.get(parent).add(root);
      }
      buildMap(root.left,root,map);
      buildMap(root.right,root,map);

    }
}


```


### 339.Nested List Weight Sum

这属于N-Array的树的节点求和问题，可以和pathSum问题一起考虑 


```java
class Solution {
    public int depthSum(List<NestedInteger> nestedList) {
        return dfs(nestedList,1);
    }
    private int dfs(List<NestedInteger> nestedList, int level){
        int res = 0;
        for(NestedInteger e:nestedList){
            if(e.isInteger()){
              res+=level*e.getInteger();
            }else{
              res+=dfs(e.getList(),level+1);
            }
        }
      return res;
    }
}
```






