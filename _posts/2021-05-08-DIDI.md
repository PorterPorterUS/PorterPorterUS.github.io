---
layout: post
author: Xusheng Ji
title: "DIDI coding"
tags: algorithm leetcode
---

{% include lib/mathjax.html %}


<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: [
      "MathMenu.js",
      "MathZoom.js",
      "AssistiveMML.js",
      "a11y/accessibility-menu.js"
    ],
    jax: ["input/TeX", "output/CommonHTML"],
    TeX: {
      extensions: [
        "AMSmath.js",
        "AMSsymbols.js",
        "noErrors.js",
        "noUndefined.js",
      ]
    }
  });
</script>


滴滴题目

### 243 Shortest Word Distance

给定一个字符串数组wordsDict和两个已经存在于数组中的不同字符串word1和word2，返回这两个词在列表中的最短距离。

### 1.index的初始化：index 初始化状态可以设置为-1
### 2.最终最小值结果的初始化: 求最小值，res= Math(res,xxxx); 这种语句, res的初始化数值为Integer.MAX_VALUE


```java
class Solution {
    public int shortestDistance(String[] wordsDict, String word1, String word2) {
        String targer = word1;
        String source = word2;
        int index1 = -1;
        int index2 = -1;
        int res = Integer.MAX_VALUE;
        for(int i = 0 ; i < wordsDict.length; i++){
            if(wordsDict[i].equals(source)){
              index1 = i;
              //res = Math.min(res,Math.abs(index2-index1));
            }
            if(wordsDict[i].equals(targer)){
              index2 = i;
              //res = Math.min(res,Math.abs(index2-index1));
            }
          if(index1!=-1 && index2!=-1){
            res = Math.min(res,Math.abs(index2-index1));
          }
            
        }
        return res;
      
    }
}

```

### 245 Shortest Word Distance 2

和243题目一样, 但是可以允许有相同的source and target.


```java
class Solution {
    public int shortestWordDistance(String[] wordsDict, String word1, String word2) {
        String targer = word1;
        String source = word2;
        int index1 = -1;
        int index2 = -1;
        int res = Integer.MAX_VALUE;
        for(int i = 0 ; i < wordsDict.length; i++){
            if(wordsDict[i].equals(source)){
              index1 = i;
              //res = Math.min(res,Math.abs(index2-index1));
            }
            if(wordsDict[i].equals(targer)){
              if(targer.equals(source)){
                index1 = index2;
              }
              index2 = i;
              //res = Math.min(res,Math.abs(index2-index1));
            }
          if(index1!=-1 && index2!=-1){
            res = Math.min(res,Math.abs(index2-index1));
          }
            
        }
        return res;
    }
}

```

### 序列化树的问题系列


### 606. Construct String from Binary Tree

Input: root = [1,2,3,4]

Output: "1(2(4))(3)"

Explanation: Originallay it needs to be "1(2(4)())(3()())", but you need to omit all the unnecessary empty parenthesis pairs. And it will be "1(2(4))(3)"

```java
class Solution {
    public String tree2str(TreeNode t) {
        if(t==null)
            return "";
        if(t.left==null && t.right==null)
            return t.val+"";
        if(t.right==null)
            return t.val+"("+tree2str(t.left)+")";
       if(t.left==null)
             return t.val+"()"+"("+tree2str(t.right)+")";
        return t.val+"("+tree2str(t.left)+")("+tree2str(t.right)+")";   
    }


}

```


### 297. Serialize and Deserialize Binary Tree



```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Codec {

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        if(root == null ) return "#";
        // String left = serialize(root.left);
        // String right = serialize(root.right);
        // return ""+root.val+" "+left+" "+right;
      return root.val + "," + serialize(root.left) + "," + serialize(root.right);
        
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        Queue<String> queue = new LinkedList<>(Arrays.asList(data.split(",")));
        return helper(queue);
    } 
  
    private TreeNode helper(Queue<String> q){
      String s = q.poll();
      if(s.equals("#")) return null;
      TreeNode root= new TreeNode(Integer.valueOf(s));
      root.left = helper(q);
      root.right = helper(q);
      return root;
    }
}

```


### 652. Find Duplicate Subtrees


```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {
        Map<String,List<TreeNode>> map = new HashMap<>();
        List<TreeNode> res = new ArrayList<>();
        serialize(root,map);
        for(List<TreeNode> g:map.values()){
            if(g.size()>1) res.add(g.get(0));
        }
       return res;
    }
  
    private String serialize(TreeNode node,Map<String,List<TreeNode>> map){
        if(node == null) return "";
        String s = "(" + serialize(node.left,map)+node.val+serialize(node.right,map) + ")";
        if(!map.containsKey(s)) map.put(s,new ArrayList<TreeNode>());
        map.get(s).add(node);
        return s;
    }
}

```

### 98. Validate Binary Search Tree


```java
class Solution {
    private long pre = Long.MIN_VALUE;
    public boolean isValidBST(TreeNode root) {
        if(root == null) return true;
        if(!isValidBST(root.left)) return false;
        if(root.val<=pre) return false;
        pre = root.val;
        return isValidBST(root.right);
    }
}

```




