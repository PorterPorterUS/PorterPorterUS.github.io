---
layout: post
author: Xusheng Ji
title: "DIDI coding"
tags: algorithm leetcode
categories: interview
---

{% include lib/mathjax.html %}


<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: [
      "MathMenu.js",
      "MathZoom.js",
      "AssistiveMML.js",
      "a11y/accessibility-menu.js"
    ],
    jax: ["input/TeX", "output/CommonHTML"],
    TeX: {
      extensions: [
        "AMSmath.js",
        "AMSsymbols.js",
        "noErrors.js",
        "noUndefined.js",
      ]
    }
  });
</script>


滴滴题目
### 374
```java
public int guessNumber(int n) {
    int i = 1, j = n;
    while(i < j) {
        int mid = i + (j - i) / 2;
        if(guess(mid) == 0) {
            return mid;
        } else if(guess(mid) == 1) {
            i = mid + 1;
        } else {
            j = mid;
        }
    }
    return i;
}
```

### 375
```java
public class Solution {
    public int getMoneyAmount(int n) {
        if (n == 1) {
            return 0;
        }
        int[][] dp = new int[n + 1][n + 1];
        for (int jminusi = 1; jminusi < n; jminusi++) {
            for (int i = 0; i + jminusi <= n; i++) {
                int j = i + jminusi;
                dp[i][j] = Integer.MAX_VALUE;
                for (int k = i; k <= j; k++) {
                    dp[i][j] = Math.min(dp[i][j],
                                        k + Math.max(k - 1 >= i ? dp[i][k - 1] : 0,
                                                     j >= k + 1 ? dp[k + 1][j] : 0));
                }
            }
        }
        return dp[1][n];
    }
}

```



### 380.Insert Delete GetRandom O(1)

### RandomizedSet() Initializes the RandomizedSet object.
### bool insert(int val) Inserts an item val into the set if not present. Returns true if the item was not present, false otherwise.
### bool remove(int val) Removes an item val from the set if present. Returns true if the item was present, false otherwise
### int getRandom() Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the same probability of being returned.

### 要完成insert+delete+getRandom三个操作的时间复杂度为1
### 解法：使用arraylist和HashMap
### Arraylist 负责存储value
### HashMap负责value->index的关系

### 每次插入数据，同时更新map和arrayList
### 每次删除数据, 把末尾元素覆盖到要被删除的位置,然后删除末尾元素, 同时更新map, map中需要先put再remove，因为有队列只有一个元素的情况，如果先remove再put会造成冗余数据
```java
class RandomizedSet {
    HashMap<Integer,Integer> map;
    ArrayList<Integer> list;
    Random rand;
    /** Initialize your data structure here. */
    public RandomizedSet() {
        map = new HashMap<>();
        list = new ArrayList<>();
        rand = new Random();
    }
    
    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */
    public boolean insert(int val) {
        if(map.containsKey(val)){
          return false;
        }
        int index = list.size();
        list.add(index,val);
        //list.set(index,val);
        map.put(val,list.size()-1);
        return true;
    }
    
    /** Removes a value from the set. Returns true if the set contained the specified element. */
    public boolean remove(int val) {
        if(!map.containsKey(val)){
          return false;
        }
        int lastItem = list.get(list.size()-1);
        int index = list.indexOf(val);
        list.set(index,lastItem);
        list.remove(list.size()-1);
        map.put(lastItem,index);
        map.remove(val);
        //map.put(lastItem,index);
        return true;
    }
    
    /** Get a random element from the set. */
    public int getRandom() {
        return list.get(rand.nextInt(list.size()));
    }
}

/**
 * Your RandomizedSet object will be instantiated and called as such:
 * RandomizedSet obj = new RandomizedSet();
 * boolean param_1 = obj.insert(val);
 * boolean param_2 = obj.remove(val);
 * int param_3 = obj.getRandom();
 */

```
### 460. LFU

实现 LFUCache 类：
LFUCache(int capacity) - 用数据结构的容量 capacity 初始化对象 

int get(int key) - 如果键存在于缓存中，则获取键的值，否则返回 -1。 

void put(int key, int value) - 如果键已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量时，则应该在插入新项之前，使最不经常使用的项无效。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 最久未使用 的键。 注意「项的使用次数」就是自插入该项以来对其调用 get 和 put 函数的次数之和。使用次数会在对应项被移除后置为 0 。 进阶： 你是否可以在 O(1) 时间复杂度内执行两项操作？  

### 思路: 
### 需要用两个哈希表再加上N个双链表才能实现, N为不同频率的个数, 
### 一个map, 存的是 key和node的映射,

![image](https://user-images.githubusercontent.com/60555283/119970977-64a12900-bf7e-11eb-8b3b-94a2937179a1.png)


第2个map, 存的是频率和linkedHashSet的映射, 每个linkedHashSet是相同频率的节点


![image](https://user-images.githubusercontent.com/60555283/119970988-6a970a00-bf7e-11eb-93e1-5986f618d903.png)



GET操作: 如果key不存在则返回-1
如果key存在，则返回对应的value，同时:
将元素的访问频率+1
将元素从访问频率i的链表中移除，放到频率i+1的链表中
如果频率i的链表为空，则从频率哈希表中移除这个链表

PUT操作:put操作就要复杂多了，大致包括下面几种情况

如果key已经存在，修改对应的value，并将访问频率+1
将元素从访问频率i的链表中移除，放到频率i+1的链表中
如果频率i的链表为空，则从频率哈希表中移除这个链表
如果key不存在
缓存超过最大容量，则先删除访问频率最低的元素，再插入新元素
新元素的访问频率为1，如果频率哈希表中不存在对应的链表需要创建
缓存没有超过最大容量，则插入新元素
新元素的访问频率为1，如果频率哈希表中不存在对应的链表需要创建


我们在代码实现中还需要维护一个minFreq的变量，用来记录LFU缓存中频率最小的元素，在缓存满的时候，可以快速定位到最小频繁的链表，以达到 O(1) 时间复杂度删除一个元素。 具体做法是: 更新/查找的时候，将元素频率+1，之后如果minFreq不在频率哈希表中了，说明频率哈希表中已经没有元素了，那么minFreq需要+1，否则minFreq不变。 插入的时候，这个简单，因为新元素的频率都是1，所以只需要将minFreq改为1即可。


```java
class LFUCache {
    class Node{
      int key;
      int value;
      int freq = 1;
      public Node(){}
      public Node(int key, int value){this.value = value; this.key = key;}
    }
    private int size ;
    private int capacity;
    private HashMap<Integer,Node> cache;
    private HashMap<Integer,LinkedHashSet<Node>> map;
    private int min;
    public LFUCache(int capacity) {
        this.capacity = capacity;
        this.size = 0;
        cache  = new HashMap<>();
        map =new HashMap<>();
    }
    public void freqInc(Node node){
      LinkedHashSet<Node> set = map.get(node.freq);
      set.remove(node);
      if(set.size()==0 && min == node.freq){
         min = node.freq+1;
      }
      node.freq++;
      LinkedHashSet<Node> newSet = map.get(node.freq);
      if(newSet == null){
        newSet = new LinkedHashSet<>();
        map.put(node.freq,newSet);
      }
      newSet.add(node);
    }
    public void add(Node node){
      LinkedHashSet<Node> set = map.get(1);
      if(set == null){
        set = new LinkedHashSet<>();
        map.put(1,set);
      }
      set.add(node);
      min = 1;
    }
  
    public Node delete(){
      LinkedHashSet<Node> set = map.get(min);
      Node del = set.iterator().next();
      set.remove(del);
      return del;
    }
    
    public int get(int key) {
        Node node = cache.get(key);
        if(node == null){
          return -1;
        }
         freqInc(node);
        return node.value;
    }
    
    public void put(int key, int value) {
        Node node = cache.get(key);
        if(node != null){
          node.value = value;
          freqInc(node);
        }else{
          if(size<capacity){
            size ++;
          }else{
            Node del = delete();
            cache.remove(del.key);
          }
          Node newNode = new Node(key,value);
          add(newNode);
          cache.put(key,newNode);
        }
    }
}

/**
 * Your LFUCache object will be instantiated and called as such:
 * LFUCache obj = new LFUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */

```



### 79 Word Search 
### 题目意思, 给一个字符串，给一个字母板, 求问字符串是否出现在字母板中
### 解法：利用岛屿问题的DFS模版，如果某个字母板位置的字符等于字符串中的第一个字符，并且DFS返回true，则证明找到这个字符串了
### DFS的参数:1.图,也就是grid 2. 当前图所在的位置 3.字，也就是word 4.当前word所在的位置
### DFS的内部逻辑：首先判断index>=String.length则证明已经搜索过每个字符串了于是就可以return true ++++++ 然后判断出界, 然后存储临时变量+++然后四个方向DFS
### 复杂度分析：空间复杂度为O(L),L是word的长度
### 复杂度分析：时间复杂度为O(M * N * 4^L) where M*N is the size of the board and we have 4^L for each cell because of the recursion. 
```java
class Solution {
    public boolean exist(char[][] board, String word) {
        int rows = board.length;
        int cols = board[0].length;
        for(int i = 0; i < rows; i++){
          for(int j = 0; j < cols; j++){
             if(board[i][j] == word.charAt(0) && dfs(board,i,j,word,0)){
                return true;
             }
          }
        }
        return false;
    }
  
    private boolean dfs(char[][] grid,int i, int j, String word, int index){
      if(index>=word.length()) return true;
      if(i<0 || i== grid.length || j<0 || j==grid[0].length || word.charAt(index)!=grid[i][j] || grid[i][j] == '*') return false;
      char tmp = grid[i][j];
      grid[i][j] = '*';
      if(dfs(grid,i+1,j,word,index+1) ||dfs(grid,i,j+1,word,index+1)||dfs(grid,i-1,j,word,index+1)||dfs(grid,i,j-1,word,index+1) ){
        return true;
      }
      
      grid[i][j] = tmp;
      return false;
    }
}

```


### 212 Word Search II 
### 题目意思, 给N个字符串，给一个字母板, 求问N个字符串有哪些出现在字母板中，如果出现了请把他们都打印出来
### 解法: 凡是查看一个字符串是否出现在一堆字符串集群中的问题，请使用字典树TrieTree. 可以把着N个字符串建立为TrieTree,然后在字母板中的每次DFS遍历，都把当前字符串放入到TrieTree中查看是否存在。
### 建立字典树的办法: 首先创立一个空的头节点, 再设置一个指针，每次遍历一个新的字符串的时候，都先把指针指向头节点，然后每次遍历一个字符串的字符，都查看指针.children[c-'a']是否存在，如果存在就继续下一个字符，如果不存在就建立一个空节点，然后继续下一个字符，最终遍历完整个字符串的话，就把这个节点的node.StringValue = String.
### DFS内部逻辑：首先判断出界++然后判断字典树中的元素是否存在++然后存储临时变量+++然后DFS四个方向
### DFS参数：1.grid 2.grid的位置 3.res结果集合 4.TrieNode root
### 时间复杂度分析：m*n是grid的大小，WL是所有单词的平均长度。For naive approach, runtime is O(m * n * num_words * min(4^wl, m * n)). For trie approach, runtime is O(m * n * min(4^wl, m * n) + wl * num_words). WL*num_words是建立TrieTree的时间复杂度， min(4^wl, m * n)是因为有可能M*N会比4^WL要大，而DFS最多是遍历M*N次

```java
class Solution {
    class TrieNode{
      String word;
      TrieNode[] children;
      public TrieNode(){
        children = new TrieNode[26];
        word = null;
      }
    }
    private TrieNode root = new TrieNode();
     
  
    private TrieNode buildTree(String[] words){
      //TrieNode root = new TrieNode();
      for(String word:words){
          TrieNode cur =  root;
          for(char c: word.toCharArray()){
            if(cur.children[c-'a']==null){
              cur.children[c-'a'] = new TrieNode();
            }
            cur = cur.children[c-'a'];
          }
        cur.word = word;
      }
        return root;
    }
    public List<String> findWords(char[][] board, String[] words) {
        int rows = board.length;
        int cols = board[0].length;
        List<String> res = new ArrayList<>();
        TrieNode root = buildTree(words);
        for(int i = 0 ; i < rows; i++){
          for(int j = 0; j < cols; j++){
              dfs(i,j,board,root,res);
          }
        }
        return res;
    }
    private void dfs(int i, int j, char[][] board, TrieNode root,List<String> res){
        if(i<0 || i==board.length || j<0 || j==board[0].length || board[i][j] == '*'){
          return;
        }
        char tmp = board[i][j];
        if(root.children[tmp-'a']==null) return;
        root = root.children[tmp-'a'];
        if(root.word!=null){
          res.add(root.word);
          root.word = null;
        }
       board[i][j] = '*';
      dfs(i+1,j,board,root,res);
      dfs(i-1,j,board,root,res);
      dfs(i,j+1,board,root,res);
      dfs(i,j-1,board,root,res);
        
       board[i][j] = tmp; 
    }
    
}
```


### 208.mplement Trie (Prefix Tree)
### 1. 构建字典树,完成以下函数
#### 1.Trie() Initializes the trie object.
#### 2.void insert(String word) Inserts the string word into the trie
#### 3.boolean search(String word) Returns true if the string word is in the trie (i.e., was inserted before), and false otherwise.
#### 4.boolean startsWith(String prefix) Returns true if there is a previously inserted string word that has the prefix prefix, and false otherwise

### 2. 复杂度分析：
### 2.1 构建的复杂度： 构建TrieTree的时间复杂度为O(M), M是单词的长度。在遍历输入字符串的每一步，我们要不就是创建一个新节点，要不就是访问这个节点，所以时间复杂度为O(M)。构建TrieTree的空间复杂度为O(M), M是单词的长度。 在最坏情况下，我们每一步都要创建一个新的node，所以空间复杂度最坏为O(M).
### 2.2 对于搜索的复杂度： M是单词的长度,时间复杂度为O(M),空间复杂度为O(1).
 

```java
class Trie {
    class TrieNode{
      TrieNode[] children ;
      boolean word;
      public TrieNode(){
        children = new TrieNode[26];
        word = false;
      }
    }
  
    private TrieNode root; 
    /** Initialize your data structure here. */
    public Trie() {
        root = new TrieNode();
    }
    
    /** Inserts a word into the trie. */
    public void insert(String word) {
        TrieNode cur = root;
        for(char c: word.toCharArray()){
          if(cur.children[c-'a']==null){
            cur.children[c-'a'] = new TrieNode();
          }
          cur = cur.children[c-'a'];
        }
      cur.word = true;
        //return root;
    }
    
    /** Returns if the word is in the trie. */
    public boolean search(String word) {
        TrieNode cur = root;
        for(char c: word.toCharArray()){
            if(cur.children[c-'a'] == null){
              return false;
            }
          cur = cur.children[c-'a'];
        }
      return cur.word;
    }
    
    /** Returns if there is any word in the trie that starts with the given prefix. */
    public boolean startsWith(String prefix) {
        TrieNode cur = root;
        for(char c: prefix.toCharArray()){
            if(cur.children[c-'a'] == null){
              return false;
            }
          cur = cur.children[c-'a'];
        }
      return true;
    }
}

/**
 * Your Trie object will be instantiated and called as such:
 * Trie obj = new Trie();
 * obj.insert(word);
 * boolean param_2 = obj.search(word);
 * boolean param_3 = obj.startsWith(prefix);
 */

```

### 211. Design Add and Search Words Data Structure
### 1. 构建字典树，完成以下函数
#### WordDictionary() Initializes the object.
#### void addWord(word) Adds word to the data structure, it can be matched later.
#### bool search(word) Returns true if there is any string in the data structure that matches word or false otherwise. word may contain dots '.' where dots can be matched with any letter

### 2. 复杂度分析：
### 2.1 构建的复杂度： 构建TrieTree的时间复杂度为O(M), M是单词的长度。在遍历输入字符串的每一步，我们要不就是创建一个新节点，要不就是访问这个节点，所以时间复杂度为O(M)。构建TrieTree的空间复杂度为O(M), M是单词的长度。 在最坏情况下，我们每一步都要创建一个新的node，所以空间复杂度最坏为O(M).
### 2.2 对于不存在dot的String的搜索的复杂度： M是单词的长度,时间复杂度为O(M),空间复杂度为O(1).
### 2.3 对于存在dot的String的搜索的复杂度： M是单词的长度,假如最坏的情况是输入的字符串全部为"...........", 这样的话时间复杂度为O(26^M),因为针对每一个小点都要搜索26个孩子，空间复杂度为O(M), 因为每次遍历到一个字符，就要调用一次DFS，所以为O(M).


### 3.搜索部分的思路：
### 如果是正常字符串，没有dot, 假如字符串为"abcd", 每次遍历到一个字符的时候, 就去对应的字典树节点中查询是否存在
### 如果字符串中带有dot, 例如“abc.defg”, 那么遍历到"."的时候, 要查看"."对应的level中所有的节点，例如"."在"“abc.defg"中是第4个字符，那么就要查看c的第4层的所有儿子节点, 遍历每个儿子节点，如果这个儿子不为空，那么就把这个儿子节点和字符串“(儿子)defg”传入下一层DFS中。
```java
class WordDictionary {
    class TrieNode{
      boolean word;
      TrieNode[] children;
      public TrieNode(){
        word = false;
        children = new TrieNode[26];
      }
    }
    private TrieNode root;
    /** Initialize your data structure here. */
    public WordDictionary() {
        root = new TrieNode();
    }
    
    public void addWord(String word) {
        TrieNode cur = root;
        for(char c : word.toCharArray()){
            if(cur.children[c-'a']==null){
              cur.children[c-'a'] = new TrieNode();
            }
          cur = cur.children[c-'a'];
        }
        cur.word = true;
    }
    
    public boolean search(String word) {
        return dfs(word,root);
    }
    
    public boolean dfs(String word,TrieNode cur){
       for(int i = 0; i < word.length(); i++){
          char c = word.charAt(i);
          if(c == '.' || cur.children[c-'a']==null){
            if(c == '.'){
              for(TrieNode child:cur.children){
                if(child == null) continue;
                if(dfs(word.substring(i+1),child)){
                  return true;
                }
              }
            }
            return false;
          }else{
            cur = cur.children[c-'a'];
          }
       }
      return cur.word;
    }
}

/**
 * Your WordDictionary object will be instantiated and called as such:
 * WordDictionary obj = new WordDictionary();
 * obj.addWord(word);
 * boolean param_2 = obj.search(word);
 */

```




### 844 Backspace String Compare
### Stack解决方案：space complexity: O(M+N)
```java
class Solution {
    public boolean backspaceCompare(String s, String t) {
        return check(s).equals(check(t));
    }
    private Stack check(String s){
      Stack<Character> stack = new Stack<>();
      for(char c: s.toCharArray()){
          if(c!='#'){
            stack.push(c);
          }else{
            if(!stack.isEmpty()){
              stack.pop();
            }
          }
      }
      return stack;
      
    }
}
```
### Two Pointers：space complexity: O(1)
```java
class Solution {
    public boolean backspaceCompare(String s, String t) {
        int i = s.length()-1;
        int j = t.length()-1;
        int numS = 0;
        int numT = 0;
        while(i>=0 || j>=0){ //必须遍历完所有的字符串，所以这里必须是||,不能是&&
          while(i>=0){
            if(s.charAt(i)=='#'){
              numS++;
              i--;
            }else if(numS>0){
              numS--;
              i--;
            }else{
              break;
            }
          }
          while(j>=0){
            if(t.charAt(j)=='#'){
              numT++;
              j--;
            }else if(numT>0){
              numT--;
              j--;
            }else{
              break;
            }
          }
          //如果一个正一个负，或者两个都是正但是位置的字符不一样，则返回false
          if(((i>=0)!=(j>=0)) || (i>=0&&j>=0&&(s.charAt(i)!=t.charAt(j)))){
            return false;
          }
          //两个都是负，一定是true。
          if((i<0)&&(j<0)){return true;}
          
          i--;
          j--;
          
        }
      
      return true;
    }
}

```



### 243 Shortest Word Distance

给定一个字符串数组wordsDict和两个已经存在于数组中的不同字符串word1和word2，返回这两个词在列表中的最短距离。

### 1.index的初始化：index 初始化状态可以设置为-1
### 2.最终最小值结果的初始化: 求最小值，res= Math(res,xxxx); 这种语句, res的初始化数值为Integer.MAX_VALUE


```java
class Solution {
    public int shortestDistance(String[] wordsDict, String word1, String word2) {
        String targer = word1;
        String source = word2;
        int index1 = -1;
        int index2 = -1;
        int res = Integer.MAX_VALUE;
        for(int i = 0 ; i < wordsDict.length; i++){
            if(wordsDict[i].equals(source)){
              index1 = i;
              //res = Math.min(res,Math.abs(index2-index1));
            }
            if(wordsDict[i].equals(targer)){
              index2 = i;
              //res = Math.min(res,Math.abs(index2-index1));
            }
          if(index1!=-1 && index2!=-1){
            res = Math.min(res,Math.abs(index2-index1));
          }
            
        }
        return res;
      
    }
}

```
### 245 Shortest Word Distance 2

Design a data structure that will be initialized with a string array, and then it should answer queries of the shortest distance between two different strings from the array.

Implement the WordDistance class:

WordDistance(String[] wordsDict) initializes the object with the strings array wordsDict.
int shortest(String word1, String word2) returns the shortest distance between word1 and word2 in the array wordsDict.



```java
public class WordDistance {

private Map<String, List<Integer>> map;

public WordDistance(String[] words) {
    map = new HashMap<String, List<Integer>>();
    for(int i = 0; i < words.length; i++) {
        String w = words[i];
        if(map.containsKey(w)) {
            map.get(w).add(i);
        } else {
            List<Integer> list = new ArrayList<Integer>();
            list.add(i);
            map.put(w, list);
        }
    }
}

public int shortest(String word1, String word2) {
    List<Integer> list1 = map.get(word1);
    List<Integer> list2 = map.get(word2);
    int ret = Integer.MAX_VALUE;
    for(int i = 0, j = 0; i < list1.size() && j < list2.size(); ) {
        int index1 = list1.get(i), index2 = list2.get(j);
        if(index1 < index2) {
            ret = Math.min(ret, index2 - index1);
            i++;
        } else {
            ret = Math.min(ret, index1 - index2);
            j++;
        }
    }
    return ret;
}
}
```


### 246 Shortest Word Distance 3

和243题目一样, 但是可以允许有相同的source and target.


```java
class Solution {
    public int shortestWordDistance(String[] wordsDict, String word1, String word2) {
        String targer = word1;
        String source = word2;
        int index1 = -1;
        int index2 = -1;
        int res = Integer.MAX_VALUE;
        for(int i = 0 ; i < wordsDict.length; i++){
            if(wordsDict[i].equals(source)){
              index1 = i;
              //res = Math.min(res,Math.abs(index2-index1));
            }
            if(wordsDict[i].equals(targer)){
              if(targer.equals(source)){
                index1 = index2;
              }
              index2 = i;
              //res = Math.min(res,Math.abs(index2-index1));
            }
          if(index1!=-1 && index2!=-1){
            res = Math.min(res,Math.abs(index2-index1));
          }
            
        }
        return res;
    }
}

```

### 序列化树的问题系列


### 606. Construct String from Binary Tree

### 做树类的问题, 最基本的思路是先考虑corner case,例如node==null, 然后需要考虑的是站在某个节点上应该怎么处理，想明白基本逻辑之后，把这种逻辑递推到左子树和右侧子树，最后需要考虑inorder/preorder/postOrder, 这决定了 本层业务逻辑 + 左子树 + 右子树 的执行顺序

Input: root = [1,2,3,4]

Output: "1(2(4))(3)"

Explanation: Originallay it needs to be "1(2(4)())(3()())", but you need to omit all the unnecessary empty parenthesis pairs. And it will be "1(2(4))(3)"

```java
class Solution {
    public String tree2str(TreeNode t) {
        if(t==null)
            return "";
        if(t.left==null && t.right==null)
            return t.val+"";
        if(t.right==null)
            return t.val+"("+tree2str(t.left)+")";
       if(t.left==null)
             return t.val+"()"+"("+tree2str(t.right)+")";
        return t.val+"("+tree2str(t.left)+")("+tree2str(t.right)+")";   
    }


}

```


### 297. Serialize and Deserialize Binary Tree



```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Codec {

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        if(root == null ) return "#";
        // String left = serialize(root.left);
        // String right = serialize(root.right);
        // return ""+root.val+" "+left+" "+right;
      return root.val + "," + serialize(root.left) + "," + serialize(root.right);
        
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        Queue<String> queue = new LinkedList<>(Arrays.asList(data.split(",")));
        return helper(queue);
    } 
  
    private TreeNode helper(Queue<String> q){
      String s = q.poll();
      if(s.equals("#")) return null;
      TreeNode root= new TreeNode(Integer.valueOf(s));
      root.left = helper(q);
      root.right = helper(q);
      return root;
    }
}

```


### 652. Find Duplicate Subtrees


```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {
        Map<String,List<TreeNode>> map = new HashMap<>();
        List<TreeNode> res = new ArrayList<>();
        serialize(root,map);
        for(List<TreeNode> g:map.values()){
            if(g.size()>1) res.add(g.get(0));
        }
       return res;
    }
  
    private String serialize(TreeNode node,Map<String,List<TreeNode>> map){
        if(node == null) return "";
        String s = "(" + serialize(node.left,map)+node.val+serialize(node.right,map) + ")";
        if(!map.containsKey(s)) map.put(s,new ArrayList<TreeNode>());
        map.get(s).add(node);
        return s;
    }
}

```

###  98. Validate Binary Search Tree


```java
class Solution {
    private long pre = Long.MIN_VALUE;
    public boolean isValidBST(TreeNode root) {
        if(root == null) return true;
        if(!isValidBST(root.left)) return false;
        if(root.val<=pre) return false;
        pre = root.val;
        return isValidBST(root.right);
    }
}

```
### course schedule 

###  210. Course Schedule II


```java
class Solution {
    public int[] findOrder(int numCourses, int[][] prerequisites) {
      int[] res = new int[numCourses];  
      HashMap<Integer,List<Integer>> graph = new HashMap<>();
      HashMap<Integer,Integer> inDegree = new HashMap<>();
      for(int i = 0 ; i < numCourses ; i++){
        graph.put(i,new ArrayList<>());
        inDegree.put(i,0);
      }
      for(int[] pre:prerequisites){
        int cur = pre[0];
        int pr = pre[1];
        //graph.get(cur).add(pr);
        graph.get(pr).add(cur);
        inDegree.put(cur,inDegree.get(cur)+1);
      }
      
      Queue<Integer> queue = new LinkedList<>();
      for(int i = 0; i < numCourses;i++){
        if(inDegree.get(i) == 0){
          queue.offer(i);
        }
      }
      
      int index = 0;
      //if(queue.isEmpty()) return  new int[0];
      boolean flag = true;
      while(!queue.isEmpty()){
        int size = queue.size();
       
        for(int i = 0 ; i < size; i++){
           flag = false;
            int key = queue.poll();
            inDegree.remove(key);
            res[index++] = key;
            for(Integer nei:graph.get(key)){
               inDegree.put(nei,inDegree.get(nei)-1);
               if(inDegree.get(nei) == 0) {
                 queue.offer(nei);
                 //flag = false;
               }
               
            }
        }
         if(flag) return new int[0];
        
      }
      
      return res;
    }
}

```



#### 1462. Course Schedule IV


```java
 class Solution {
    public List<Boolean> checkIfPrerequisite(int n, int[][] prerequisites, int[][] queries) {
      int[] indegree = new int[n];
        Map<Integer, Set<Integer>> adj = new HashMap<>(); 
        Map<Integer, Set<Integer>> prerequisitesMap = new HashMap<>(); 
        
        for (int i = 0 ; i < n; i++) {
            prerequisitesMap.put(i, new HashSet<>());
            adj.put(i, new HashSet<>());
        }
        
        for (int[] pre : prerequisites) {
            indegree[pre[1]]++;
            adj.get(pre[0]).add(pre[1]);
        }
        
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < n; i++) {
            if (indegree[i] == 0) {
                queue.offer(i);
            }
        }
        
        while (!queue.isEmpty()) {
            int node = queue.poll();            
            Set<Integer> set = adj.get(node);
            for (int next : set) {
                prerequisitesMap.get(next).add(node);
                prerequisitesMap.get(next).addAll(prerequisitesMap.get(node));
                indegree[next]--;
                if (indegree[next] == 0) {
                    queue.offer(next);
                }
            }
        }
    
        List<Boolean> res = new ArrayList<>();
        for (int[] pair : queries) {
            Set<Integer> set = prerequisitesMap.get(pair[1]);
            if (set.contains(pair[0])) {
                res.add(true);
            }
            else {
                res.add(false);
            }
        }
        return res;
	}
}

```

### 207. Course Schedule
```java
class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        int[] visited = new int[numCourses];
        List<List<Integer>> adj = new ArrayList<>();
        for(int i =0 ; i < numCourses; i++){
          adj.add(new ArrayList<>());
        }
        for(int[] pre:prerequisites){
          adj.get(pre[1]).add(pre[0]);
        }
      
        for(int i = 0 ; i < numCourses; i++){
          if(!dfs(i,adj,visited)) return false;
        }
        return true;
    }
  
    private boolean dfs(int node, List<List<Integer>> adj, int[] visited){
      if(visited[node] == 1) return false;
      if(visited[node] == -1) return true;
      
      visited[node] = 1;
      for(Integer arr:adj.get(node)){
        if(!dfs(arr,adj,visited)) return false;
      }
      visited[node] = -1;
      return true;
      
    }
}

```
### 221. MAX Square 

### 统计以(i,j)(i,j)为根据点，看看周围的1能不能组成一个正方形，如果能，算出这个面积就可以了。

### https://leetcode-cn.com/problems/maximal-square/solution/221-zui-da-zheng-fang-xing-tu-jie-shi-pin-yan-shi-/

```java
class Solution {
    public int maximalSquare(char[][] a) {
    if(a.length == 0) return 0;
    int m = a.length, n = a[0].length, result = 0;
    int[][] b = new int[m+1][n+1];
    for (int i = 1 ; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if(a[i-1][j-1] == '1') {
                b[i][j] = Math.min(Math.min(b[i][j-1] , b[i-1][j-1]), b[i-1][j]) + 1;
                result = Math.max(b[i][j], result); // update result
            }
        }
    }
    return result*result;
}
}
```

### 63. Unique Paths II

```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        if(obstacleGrid[0][0] ==1) return 0;
        int[][] dp = new int[obstacleGrid.length][obstacleGrid[0].length];
        for(int i = 0; i < obstacleGrid.length ; i++){
            if(obstacleGrid[i][0] == 1){
                dp[i][0] = 0;
                break;
            }else{
              dp[i][0] = 1;
            }
        }
      
        for(int i = 0; i < obstacleGrid[0].length ; i++){
            if(obstacleGrid[0][i] == 1){
                dp[0][i] = 0;
                break;
            }else{
              dp[0][i] = 1;
            }
            
        }
      
        for(int i = 1; i < obstacleGrid.length ; i++){
          for(int j = 1; j < obstacleGrid[0].length; j++){
              if(obstacleGrid[i][j] == 1){
                dp[i][j] = 0;
              }else{
                 dp[i][j] = dp[i-1][j]+dp[i][j-1];
              }
          }
        }
        return dp[obstacleGrid.length-1][obstacleGrid[0].length-1];
    }
}

```

### 915. Partition Array into Disjoint Intervals
找一个位置，把原始数组划分为两个不同的左右数组，使得左侧数组的最大值 <= 右侧数组的最小值，并且要求左侧数组尽可能的小

### 第一种方案, 从左向右侧遍历每个元素，拿到每个位置的最大值，然后从右向左侧遍历每个元素，拿到每个位置的最小值，然后找到第一个位置使得分界线左侧的最大值<= 分界线右侧的最小值
```java
class Solution {
    public int partitionDisjoint(int[] A) {
        int[] maxs = new int[A.length];
        int[] mins = new int[A.length];
        int max = Integer.MIN_VALUE;
        int min = Integer.MAX_VALUE;
        int res = -1;
        for(int i = 0 ; i< A.length ;i++){
            max = Math.max(max,A[i]);
            maxs[i] = max;
        }
        
         for(int i = A.length-1 ; i>0 ;i--){
            min = Math.min(min,A[i]);
            mins[i] = min;
        }
        for(int i = 0 ; i < A.length-1;i++){
            if(maxs[i]<=mins[i+1]){
              res = i+1;
              break;
            }
        }
      return res;
    }
}

```


### 第二种方案, 
### [0,partitionSpot] is the left partion
###     [partitionSpot+1, i-1] is the second partion
###     [i,length-1] is the last partition, which is to be processed.   
     
###     all elements from second partition are great or equal to the first partition's max.
###    we maintain two max: 
###     leftPartitionMax: the max value for first partition [0->partitionSpot]
###     maxUntilI: the max value for all elements we already visited [0, i];
     
###     partitionSpot is the spot where we should partition the subarray[0, i-1],
     
###    now if A[i]<leftPartitionMax, it means should re-partition subarray[0,i], with i as the partitionSpot,
###    and assign maxUntilI to leftPartitionMax, because now the first partition became: [0, i].
 
```java
class Solution {
    public int partitionDisjoint(int[] A) {
        int preMax = A[0];
        int max = preMax;
        int res = 0;
        for(int i = 1 ; i < A.length; i++){
            max = Math.max(max,A[i]);
            if(A[i]<preMax){
              preMax = max;
              res = i;
            }
        }
        return res+1;
    }
}


```


### 787. Cheapest Flights Within K Stops
### 时间复杂度：因为用的是临接矩阵,所以时间复杂度为O((V+E)LogV).
### 空间复杂度: 因为用的是临接矩阵,所以时间复杂度O(V+E), E is for adjency list and V is for visited hashset.
```java
class Solution {
    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {
        HashMap<Integer,HashMap<Integer,Integer>> map = new HashMap<>();
        //构建图 cur_city->(nei_city,nei_city_price)
        for(int i = 0; i < n; i++){
            map.put(i,new HashMap<>());
        }
        for(int[] flight:flights){
          int city = flight[0];
          int cityNext = flight[1];
          int price = flight[2];
          map.get(city).put(cityNext,price);
        }
        //构建PQ,使得按照price从小到大排序.
        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->a[2]-b[2]);
        //构建visited, (city:stops)
        HashMap<Integer,Integer> visited = new HashMap<>();
        //city,stops,price
        pq.offer(new int[]{src,-1,0});
        //开始Dijkstra
        while(!pq.isEmpty()){
            int size = pq.size();
            for(int i = 0; i < size; i++){
                int[] cur = pq.poll();
                int city = cur[0];
                int stops = cur[1];
                int price = cur[2];
              //如果已经触碰到终点,直接返回
                if(city == dst) return price;
              //如果已经用光了stops,尝试下一条路径
                if(k==stops) continue;
                visited.put(city,stops);
                for(int next:map.get(city).keySet()){
                  //如果这个City之前没走过 或者 这个city走过但是之前的stops太大了,
                  //那么就可以尝试这个next city
                  if(!visited.containsKey(next)||stops<visited.get(next)){
                    pq.offer(new int[]{next,stops+1,price+map.get(city).get(next)});
                  }
                }
            }
        }
      return -1;
        
    }
}

```

### 1166.Design File System

### 创建一个file system,使得可以创建和查询path,一个合理的path的格式为"/xxx/xxx/xxx", ""以及"/"不合法
### 1.bool createPath（string path，int value）创建一个新路径，并在可能的情况下将一个值与之关联并返回true。 如果路径已经存在或其父路径不存在，则返回false。
### 2.int get（string path）返回与path关联的值，如果路径不存在，则返回-1。

### 1.创建path的时候需要注意两点，首先确认字符串是合法的，再确认当前path没有被创建过，最后确认这个路径的父母存在于map中。
```java
class FileSystem {
    HashMap<String,Integer> map;
    public FileSystem() {
        map = new HashMap<>();
    }
    
    public boolean createPath(String path, int value) {
        if(path==null || path.equals("/") || map.containsKey(path)){
          return false;
        }
        int index = path.lastIndexOf("/");
        String parent = path.substring(0,index);
        if(parent.length()>0 && !map.containsKey(parent)){
             return false;
        }
     map.put(path,value);
        return true;
     
    }
    
    public int get(String path) {
        return map.getOrDefault(path,-1);
    }
}
```
### 1239.Maximum Length of a Concatenated String with Unique Characters
### 给定一个字符串数组arr。 字符串s是具有唯一字符的arr子序列的串联。返回s的最大可能长度。
### 思路类似于 subSetI

```java
class Solution {
    private int res = 0;
    public int maxLength(List<String> arr) {
      dfs(arr,0,"");  
      return res;
    }
    
    private void dfs(List<String> arr, int start, String s){
      if(!valid(s)) return;
      res = Math.max(res,s.length());
      for(int i = start ; i < arr.size(); i++){
        dfs(arr,i+1,s+arr.get(i));
      }
      
    }
    private boolean valid(String s){
      int[] hash = new int[26];
      for(char c: s.toCharArray()){
        hash[c-'a']++;
      }
      for(int i = 0 ; i < 26; i++){
        if(hash[i]>1) return false;
      }
      return true;
    }
}
```


### 340. Longest Substring with At Most K Distinct Characters
### 解法思路：Sliding Window + HashMap 解决
### HashMap,存储的key是每个字符, value存储的是每个字符对应的rightMost的索引
### Sliding Window, 设置左右指针，右侧指针恒定向前移动, 并且恒定更新map的每个字符对应的index,同时恒定的去更新res = Math.max(res,right-left+1);
### 左侧指针在map.size>K的时候进行移动，当map.size>K的时候把map中rightMost最小对应的Character从map中删除。 然后把left指针更新为最小的rightMost_index + 1.
```java

class Solution {
    public int lengthOfLongestSubstringKDistinct(String s, int k) {
        if(k == 0) return 0;
        int maxLen = 0;
        HashMap<Character,Integer> map = new HashMap<>();
        int left = 0;
        int right = 0;
        while(right < s.length()){
          map.put(s.charAt(right),right);
          if(map.size()>k){
            int oldIndex = Collections.min(map.values());
            map.remove(s.charAt(oldIndex));
            left = oldIndex+1;
          }
          maxLen = Math.max(maxLen,right-left+1);
          right ++ ;
        }
      return maxLen;
    }
}
```




### 33. Search in Rotated Sorted Array

给定一个排序完成的数组, 例如 [1,2,3,4,5,6,7,8], 在某个位置进行反转,变为[4,5,6,7,8,1,2,3], 问在这个数组中查找某个元素的索引


### 解法： 数组会分为两段, 一段[4,5,6,7,8], 另外一段[1,2,3], 每段都是上升趋势的, 并且第二段在第一段的下面, 
### 所以在做binary search的时候, 需要考虑在那一段？？

```java
class Solution {
    public int search(int[] nums, int target) {
        if(nums == null || nums.length == 0) return -1;
        int start = 0 ;
        int end = nums.length - 1;
        while(start+1<end){
          int mid = start+(end-start)/2;
          if(nums[mid] == target) return mid;
          if(nums[mid]>nums[start]){ //mid在第一段
            if(target>=nums[start] && target<=nums[mid]){end = mid;} // target在start和mid之间,把end拉到mid位置
            else{start = mid;} // target在mid和end之间,把start拉到mid位置
          }else if (nums[mid]<nums[end]){// mid在第二段
            if(target<=nums[end] && target>=nums[mid]){start = mid;} // target在end和mid之间,把start拉到mid位置
            else{end = mid;} //target在start和mid之间,把end拉到mid 位置
          }
        }
      
       if(nums[start] == target) return start;
      if(nums[end] == target) return end;
      return -1;
    }
}

```



### 347. Top K Frequent Elements

### 思路: 首先创建HashMap, 对应的关系为 number => freq 
### 然后创建一个list,其中每个元素都是一个ArrayList, list[freq] = {1,2,3,4},意思为{1,2,3,4}出现的频率都为freq
### 最后按照ArrayList的倒叙, 向结果集中存放元素，当元素个数等于K的时候，退出


```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        //1. hashmap store num->freq
        //2. 2d array list[freq]=ArrayList
        //3. back for loop the arraylist 
        HashMap<Integer,Integer> map=new HashMap<>();
        for(int num:nums){
            map.put(num,map.getOrDefault(num,0)+1);
        }
        List<Integer>[] list=new List[nums.length+1];
        for(int num:map.keySet()){
            int freq=map.get(num);
            if(list[freq]==null){
                list[freq]=new ArrayList<>();
            }
            list[freq].add(num);
        }
        ArrayList<Integer> res=new ArrayList<>();
        for(int i=list.length-1;i>=0 && res.size()<k;i--){
            if(list[i]!=null){
                res.addAll(list[i]);
            }
        }
        return res.stream().mapToInt(Integer::valueOf).toArray();
        
        
    }
}

```


### 692. Top K Frequent Words

### 和347题一样，但是元素改为了字符串, 并且当出现了两个字符串频率相同的情况，因为先按照字母顺序从大到小排列

### 思路：首先创建HashMap, 对应的关系为 String => freq

### 然后创建一个PriorityQueue, 是一个minHeap, 首先按照频率从小到大排序，然后相同频率的字符串按照字母顺序从小到大排序。

### 为了保证时间复杂度为 O(NlogK),N是需要遍历多少个元素,K是PriorityQueue的大小, 只有实现了minheap,等到其大小大于K然后poll的话，才能保证O(NlogK)的时间复杂度。

### 把PQ中的元素, 倒序插入到结果集合中，出现的结果就是，首先是频率大的，然后频率相同的话按照从小到大排列

```java
class Solution {
    public List<String> topKFrequent(String[] words, int k) {
        
        List<String> result = new LinkedList<>();
        Map<String, Integer> map = new HashMap<>();
        for(int i=0; i<words.length; i++)
        {
          map.put(words[i],map.getOrDefault(words[i],0)+1);
        }
        
        PriorityQueue<Map.Entry<String, Integer>> pq = new PriorityQueue<>(
                 (a,b) -> a.getValue()==b.getValue() ? b.getKey().compareTo(a.getKey()) : a.getValue()-b.getValue()
        );
        for(Map.Entry<String,Integer> e:map.entrySet()){
             pq.offer(e);
             if(pq.size()>k){
               pq.poll();
             }
        }

      
        while(!pq.isEmpty())
            result.add(0, pq.poll().getKey());
        
        return result;
    }
}

```

### 426. Convert Binary Search Tree to Sorted Doubly Linked List
```java
/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val,Node _left,Node _right) {
        val = _val;
        left = _left;
        right = _right;
    }
};
*/

class Solution {
    Node prev = null;
    public Node treeToDoublyList(Node root) {
        if(root == null) return null;
        Node head = new Node(0,null,null);
        prev = head;
        //connect all the inner nodes;
        helper(root);
        //connect head and tail;
        head.right.left = prev;
        prev.right = head.right;
        return head.right;
    }
    private void helper(Node cur){
      if(cur == null) return;
        helper(cur.left);
       prev.right = cur;
      cur.left = prev;
      prev =cur;
      helper(cur.right);
    }
}

```



### Iterator

```java
package com.company;

import java.util.ArrayList;
import java.util.ConcurrentModificationException;
import java.util.Iterator;
import java.util.NoSuchElementException;

public class MyIterator<T> implements Iterator<T> {
    protected ArrayList<T> data;
    protected int index;
    protected  int lastIndex;
    public MyIterator(final ArrayList<T> data){
        this.data = data;
        this.index =0;
        this.lastIndex = -1;
    }

    @Override
    public boolean hasNext() {
        return index<data.size();
    }

    @Override
    public T next() {
        int i = this.index;
        if(!hasNext()){
            throw new NoSuchElementException();
        }
        index = i+1;
        lastIndex = i;
        return (T) data.get(index);
    }

    @Override
    public void remove() {
        if(lastIndex <0 ){
            throw new IllegalStateException();
        }
        try{
            data.remove(lastIndex);
            index = lastIndex;
            lastIndex = -1;
        }catch(IndexOutOfBoundsException e){
            throw  new ConcurrentModificationException();
        }
    }


    public boolean remove(Object o){
        int res = -1;
        if(o == null){
            for (int i = 0; i <data.size() ; i++) {
                if(data.get(i)==null){
                    res = i;
                }
            }
        }else{
            for (int i = 0; i <data.size();  i++) {
                if(o.equals(data.get(i))){
                    res = i;
                }
            }
        }
        if(res!=-1){
            data.remove(res);
            return true;
        }
        return false;
    }
}


```


### Linux shell command

```java

sort -u -r -n test.txt > output.txt

sort -n -k 2 -t : facebook.txt  按照数值排列, 并且第二列排序，并且分隔符为":"

sort -r number.txt -o  output.txt 按照升序排列，然后输出到output.txt

ps -ef | grep contest

cat test.txt | grep -f test2.txt 

输出test.txt文件中含有从test2.txt文件中读取出的关键词的内容行


cat test.txt | grep -nf test2.txt

输出test.txt文件中含有从test2.txt文件中读取出的关键词的内容行，并显示每一行的行号


grep 'linux' test.txt test2.txt 

从多个文件中查找关键词


```



